#labels 性能测试
= 介绍 =

以前的性能测试是拿JEXL作为比较对象，由于JEXL与Fel的执行速度不是一个级别的。这次就选用Java作为比较对象。看看Fel和Java之间的速度差异。


*备注：以下所有测试中的时间统计都没有包含编译时间。

= 软硬件环境 =

||操作系统	|| Microsoft Windows 7 Home Basic SP1 64bit||
||CPU 	||Intel(R) Core(TM) i3-2310M CPU@2.10GHz||
||内存 	||4G ddr3-1333 ||
||JDK 	||java version "1.6.0_26"||
||Fel   ||0.5||
||Jvm参数||-server||
||表达式执行次数||1亿次||


= 变量 =
{{{
Map<String, Object> vars = new HashMap<String, Object>(); 
vars.put("i", 100); 
vars.put("pi", 3.14d); 
vars.put("d", -3.9); 
vars.put("b", (byte) 4); 
vars.put("bool", false); 
Map<String,Object> m = new HashMap<String, Object>(); 
m.put("d", 5); 
m.put(null,"this is null"); 
vars.put("m", m); 
vars.put("s","hello world");
}}}


==场景1：常量计算==
表达式：
{{{
1000+100.0*99-(600-3*15)%(((68-9)-3)*2-100)+10000%7*71
}}}

执行结果：11181.0

||EL	||耗时（ms)||
||fel	||30||
||jexl	||45098||



==场景2：包含多个变量的布尔表达式==
表达式：
{{{
i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99 ==i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99
}}}

执行结果：true

||EL	||耗时（ms)||
||fel	||880||
||jexl	||36733||

==场景3：包含多个变量的算术表达式==
表达式：
{{{
pi*d+b-(1000-d*b/pi)/(pi+99-i*d)-i*pi*d/b
}}}

执行结果：295.86196287059323

||EL	||耗时（ms)||
||fel   ||613||
||jexl	||16907||

==场景4：调用JAVA方法==
表达式：
{{{
s.substring(m.d)
}}}

执行结果： world
||EL	||耗时（ms)||
||fel	||398||
||jexl	||8204||


==场景5：嵌套调用JAVA方法==
表达式：
{{{
s.substring(1).substring(2).indexOf('world')
}}}

执行结果：3
||EL	||耗时（ms)||
||fel	||446||
||jexl	||7189||

==测试结论：==

*常量表达式：比Jexl快得太多了，主要是Fel对常量表达式作了优化。

*包含多个变量的表达式：Fel比Jexl快20以上。Fel同样对变量访问作了优化。

*字符串访问：Fel快了近20倍。