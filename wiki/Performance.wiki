#labels 性能测试
= 介绍 =

选用Jexl作为比较对象是对不住Jexl了。在Fel出现之前，使用的是Jexl，对它还是有感情的。

Jexl毕竟没有将表达式编译成字节码，所以效率不是非常高，对比测试也有失公平。 

当然，Fel在性能上并不是专找软柿子比较。 

目前还没有发现开源的EL比Fel快。如果有，请告诉我，我也学习一下。

*备注：以下所有测试中的时间统计都没有包含编译时间。

= 软硬件环境 =

||操作系统	|| Microsoft Windows 7 Home Basic SP1 64bit||
||CPU 	||Intel(R) Core(TM) i3-2310M CPU@2.10GHz||
||内存 	||4G ddr3-1333 ||
||JDK 	||java version "1.5.0_22"||
||Fel   ||0.4||
||Jexl  ||2.0.1||

= 变量 =
{{{
Map<String, Object> vars = new HashMap<String, Object>(); 
vars.put("i", 100); 
vars.put("pi", 3.14d); 
vars.put("d", -3.9); 
vars.put("b", (byte) 4); 
vars.put("bool", false); 
Map<String,Object> m = new HashMap<String, Object>(); 
m.put("d", 5); 
m.put(null,"this is null"); 
vars.put("m", m); 
vars.put("s","hello world");
}}}


==场景1：常量计算==
表达式：{{{1000+100.0*99-(600-3*15)%(((68-9)-3)*2-100)+10000%7*71}}}

执行结果：11181.0

||EL	||速度（ms)||
||fel	||62||
||jexl	||57131||


==场景2：包含多个变量的布尔表达式==
表达式：{{{i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99 ==i * pi + (d * b - 199) / (1 - d * pi) - (2 + 100 - i / pi) % 99}}}

执行结果：true

||EL	||速度（ms)||
||fel	||1405||
||jexl	||46648||

==场景3：包含多个变量的算术表达式==
表达式：{{{pi*d+b-(1000-d*b/pi)/(pi+99-i*d)-i*pi*d/b}}}

执行结果：295.86196287059323

||EL	||速度（ms)||
||fel   ||1419||
||jexl	||21941||

==场景4：调用JAVA方法[/size]==
表达式：{{{s.substring(m.d)}}}

执行结果： world
||EL	||速度（ms)||
||fel	||686||
||jexl	||15455||


==场景5：嵌套调用JAVA方法==
表达式：{{{s.substring(1).substring(2).indexOf('world')}}}

执行结果：3
||EL	||速度（ms)||
||fel	||861||
||jexl	||19260||

==测试结论：==

*常量表达式：比Jexl快得太多了，主要是Fel对常量表达式作了优化。

*包含多个变量的表达式：Fel比Jexl快10倍甚至几十倍。Fel同样对变量访问作了优化。

*字符串访问：Fel还是快20倍以上。